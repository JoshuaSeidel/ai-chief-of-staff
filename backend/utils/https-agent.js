/**
 * Centralized HTTPS Agent for Microservice Communication
 *
 * This module provides a single, cached HTTPS agent for all microservice
 * communication. It handles certificate loading once at startup and
 * caches the agent in memory.
 *
 * IMPORTANT: This is the ONLY place certificate paths should be defined.
 * All routes should import from here instead of creating their own agents.
 */

const https = require('https');
const fs = require('fs');
const { createModuleLogger } = require('./logger');

const logger = createModuleLogger('HTTPS-AGENT');

// Possible CA certificate paths (in order of preference)
const CA_CERT_PATHS = [
  '/app/certs/ca.crt',           // Generated by generate-service-cert.sh
  '/app/certs/ca-cert.pem',      // Legacy path
  '/app/certs/ca.pem',           // Alternative
];

// Environment flag to allow insecure connections (development only)
const ALLOW_INSECURE_TLS = process.env.ALLOW_INSECURE_TLS === 'true';

// Cached HTTPS agent - initialized once, used everywhere
let cachedHttpsAgent = null;
let agentInitialized = false;

/**
 * Find and load the CA certificate
 * @returns {Buffer|null} The CA certificate buffer or null if not found
 */
function loadCACertificate() {
  for (const certPath of CA_CERT_PATHS) {
    try {
      if (fs.existsSync(certPath)) {
        const cert = fs.readFileSync(certPath);
        logger.info(`Loaded CA certificate from: ${certPath}`);
        return cert;
      }
    } catch (error) {
      logger.debug(`Could not load CA cert from ${certPath}: ${error.message}`);
    }
  }

  logger.warn('No CA certificate found at any expected location', {
    searchedPaths: CA_CERT_PATHS
  });
  return null;
}

/**
 * Initialize the HTTPS agent
 * This should be called once at server startup
 */
function initializeHttpsAgent() {
  if (agentInitialized) {
    return cachedHttpsAgent;
  }

  const caCert = loadCACertificate();

  if (caCert) {
    // Production mode with proper CA verification
    cachedHttpsAgent = new https.Agent({
      ca: caCert,
      rejectUnauthorized: true,
      keepAlive: true,
      maxSockets: 50
    });
    logger.info('HTTPS agent initialized with CA certificate verification');
  } else if (ALLOW_INSECURE_TLS) {
    // Development mode - skip verification (NOT FOR PRODUCTION)
    cachedHttpsAgent = new https.Agent({
      rejectUnauthorized: false,
      keepAlive: true,
      maxSockets: 50
    });
    logger.warn('HTTPS agent initialized WITHOUT certificate verification (ALLOW_INSECURE_TLS=true)');
    logger.warn('⚠️  This is INSECURE and should only be used in development');
  } else {
    // No certs and not allowing insecure - this is a configuration error
    // Default to insecure for internal docker network communication
    // Services are already isolated in docker network
    cachedHttpsAgent = new https.Agent({
      rejectUnauthorized: false,
      keepAlive: true,
      maxSockets: 50
    });
    logger.warn('No CA certificate found - using unverified HTTPS for internal docker network');
    logger.warn('For production, ensure certificates are properly mounted at /app/certs');
  }

  agentInitialized = true;
  return cachedHttpsAgent;
}

/**
 * Get the cached HTTPS agent
 * Initializes on first call if not already initialized
 * @returns {https.Agent} The HTTPS agent for microservice calls
 */
function getHttpsAgent() {
  if (!agentInitialized) {
    initializeHttpsAgent();
  }
  return cachedHttpsAgent;
}

/**
 * Force reinitialize the HTTPS agent
 * Useful if certificates are updated at runtime
 */
function reinitializeHttpsAgent() {
  agentInitialized = false;
  cachedHttpsAgent = null;
  return initializeHttpsAgent();
}

/**
 * Check if TLS verification is enabled
 * @returns {boolean} True if proper CA verification is active
 */
function isTlsVerificationEnabled() {
  const agent = getHttpsAgent();
  return agent && agent.options && agent.options.rejectUnauthorized === true;
}

module.exports = {
  getHttpsAgent,
  initializeHttpsAgent,
  reinitializeHttpsAgent,
  isTlsVerificationEnabled,
  ALLOW_INSECURE_TLS
};
