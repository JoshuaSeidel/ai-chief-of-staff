/**
 * Centralized HTTPS Agent for Microservice Communication
 *
 * This module provides a single, cached HTTPS agent for all microservice
 * communication. It handles certificate loading once at startup and
 * caches the agent in memory.
 *
 * IMPORTANT: This is the ONLY place certificate paths should be defined.
 * All routes should import from here instead of creating their own agents.
 */

const https = require('https');
const fs = require('fs');
const { createModuleLogger } = require('./logger');

const logger = createModuleLogger('HTTPS-AGENT');

// Possible CA certificate paths (in order of preference)
const CA_CERT_PATHS = [
  '/app/certs/ca.crt',           // Generated by generate-service-cert.sh
  '/app/certs/ca-cert.pem',      // Legacy path
  '/app/certs/ca.pem',           // Alternative
];

// Environment flag to allow insecure connections (development only)
// Support multiple truthy values: 'true', '1', 'yes', 'on' (case-insensitive)
const ALLOW_INSECURE_TLS = ['true', '1', 'yes', 'on'].includes(
  (process.env.ALLOW_INSECURE_TLS || '').toLowerCase()
);

// Log the flag on module load
logger.info(`HTTPS Agent module loaded. ALLOW_INSECURE_TLS=${ALLOW_INSECURE_TLS} (from env: ${process.env.ALLOW_INSECURE_TLS})`);

// Cached HTTPS agent - initialized once, used everywhere
let cachedHttpsAgent = null;
let agentInitialized = false;

/**
 * Find and load the CA certificate
 * @returns {Buffer|null} The CA certificate buffer or null if not found
 */
function loadCACertificate() {
  logger.info('Searching for CA certificate...');

  for (const certPath of CA_CERT_PATHS) {
    try {
      logger.debug(`Checking path: ${certPath}`);
      if (fs.existsSync(certPath)) {
        const cert = fs.readFileSync(certPath);
        logger.info(`‚úÖ Loaded CA certificate from: ${certPath} (${cert.length} bytes)`);
        return cert;
      } else {
        logger.debug(`Path does not exist: ${certPath}`);
      }
    } catch (error) {
      logger.warn(`Error reading cert from ${certPath}: ${error.message}`);
    }
  }

  logger.warn('‚ùå No CA certificate found at any expected location', {
    searchedPaths: CA_CERT_PATHS
  });
  return null;
}

/**
 * Initialize the HTTPS agent
 * This should be called once at server startup
 */
function initializeHttpsAgent() {
  if (agentInitialized && cachedHttpsAgent) {
    logger.debug('HTTPS agent already initialized, returning cached agent');
    return cachedHttpsAgent;
  }

  logger.info('=== Initializing HTTPS Agent ===');
  logger.info(`ALLOW_INSECURE_TLS environment variable: ${process.env.ALLOW_INSECURE_TLS}`);
  logger.info(`ALLOW_INSECURE_TLS parsed value: ${ALLOW_INSECURE_TLS}`);

  // IMPORTANT: ALLOW_INSECURE_TLS takes priority over CA certificate
  // This is because in Docker environments, each container may generate
  // its own CA, causing certificate chain validation to fail even when
  // a CA cert exists. When ALLOW_INSECURE_TLS=true, skip verification.
  if (ALLOW_INSECURE_TLS) {
    cachedHttpsAgent = new https.Agent({
      rejectUnauthorized: false,
      keepAlive: true,
      maxSockets: 50
    });
    logger.warn('‚ö†Ô∏è  HTTPS agent initialized WITHOUT certificate verification (ALLOW_INSECURE_TLS=true)');
    logger.warn('‚ö†Ô∏è  This is INSECURE and should only be used in development');
    agentInitialized = true;
    logger.info(`=== HTTPS Agent Ready (rejectUnauthorized=false) ===`);
    return cachedHttpsAgent;
  }

  // Production mode: try to load and use CA certificate
  const caCert = loadCACertificate();

  if (caCert) {
    cachedHttpsAgent = new https.Agent({
      ca: caCert,
      rejectUnauthorized: true,
      keepAlive: true,
      maxSockets: 50
    });
    logger.info('‚úÖ HTTPS agent initialized with CA certificate verification');
  } else {
    // No CA cert and not allowing insecure - this is a config error in production
    // Default to insecure for internal docker network with strong warning
    cachedHttpsAgent = new https.Agent({
      rejectUnauthorized: false,
      keepAlive: true,
      maxSockets: 50
    });
    logger.error('üö® No CA certificate found and ALLOW_INSECURE_TLS not set');
    logger.error('üö® Defaulting to unverified HTTPS - THIS IS A SECURITY RISK');
    logger.error('üö® For production, set up proper certificates or set ALLOW_INSECURE_TLS=true for dev');
  }

  agentInitialized = true;
  logger.info(`=== HTTPS Agent Ready (rejectUnauthorized=${cachedHttpsAgent.options.rejectUnauthorized}) ===`);
  return cachedHttpsAgent;
}

/**
 * Get the cached HTTPS agent
 * Initializes on first call if not already initialized
 * @returns {https.Agent} The HTTPS agent for microservice calls
 */
function getHttpsAgent() {
  if (!agentInitialized || !cachedHttpsAgent) {
    return initializeHttpsAgent();
  }
  return cachedHttpsAgent;
}

/**
 * Force reinitialize the HTTPS agent
 * Useful if certificates are updated at runtime
 */
function reinitializeHttpsAgent() {
  logger.info('Force reinitializing HTTPS agent...');
  agentInitialized = false;
  cachedHttpsAgent = null;
  return initializeHttpsAgent();
}

/**
 * Check if TLS verification is enabled
 * @returns {boolean} True if proper CA verification is active
 */
function isTlsVerificationEnabled() {
  const agent = getHttpsAgent();
  return agent && agent.options && agent.options.rejectUnauthorized === true;
}

module.exports = {
  getHttpsAgent,
  initializeHttpsAgent,
  reinitializeHttpsAgent,
  isTlsVerificationEnabled,
  ALLOW_INSECURE_TLS
};
